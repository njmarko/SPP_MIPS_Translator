<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MAVN: ResourceAllocation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MAVN
   </div>
   <div id="projectbrief">MAVN translates higher level 32bit MIPS code to lower level MIPS assembly code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_resource_allocation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_resource_allocation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ResourceAllocation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_resource_alocation_8h_source.html">ResourceAlocation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ResourceAllocation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_resource_allocation.png" usemap="#ResourceAllocation_map" alt=""/>
  <map id="ResourceAllocation_map" name="ResourceAllocation_map">
<area href="class_visitor.html" alt="Visitor" shape="rect" coords="0,0,122,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fd01c77f504817f57450387dcc16511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#a3fd01c77f504817f57450387dcc16511">visit</a> (<a class="el" href="class_symbol_table.html">SymbolTable</a> &amp;symTab) override</td></tr>
<tr class="separator:a3fd01c77f504817f57450387dcc16511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1efca3516d54ca6bd99261742b69a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#afa1efca3516d54ca6bd99261742b69a8">handleSpill</a> (<a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;instr, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;r_vars, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;m_vars, <a class="el" href="_symbol_table_8h.html#aa6eccd0fcd66d7d4e48ade62e542dbc3">Labels</a> &amp;labels, <a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;ig, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;spilled_vars)</td></tr>
<tr class="separator:afa1efca3516d54ca6bd99261742b69a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663d36bb9dabf81d286fc8badb0a9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#ab663d36bb9dabf81d286fc8badb0a9a9">decomposeInstructions</a> (<a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;instr, <a class="el" href="class_variable.html">Variable</a> *replaced_var)</td></tr>
<tr class="separator:ab663d36bb9dabf81d286fc8badb0a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a5815f7b4989d925d06fa008db1ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#ab5a5815f7b4989d925d06fa008db1ff6">moveFromMemToImmediate</a> (<a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;instr, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;m_vars)</td></tr>
<tr class="separator:ab5a5815f7b4989d925d06fa008db1ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2692975fccf82a17c864e2be6a5f2f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#a2692975fccf82a17c864e2be6a5f2f03">createNewMemVariable</a> (<a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;m_vars)</td></tr>
<tr class="separator:a2692975fccf82a17c864e2be6a5f2f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15162a951459918287ab4e61482814a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#a15162a951459918287ab4e61482814a8">createNewRegVariable</a> (<a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;r_vars)</td></tr>
<tr class="separator:a15162a951459918287ab4e61482814a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bfb5903714cb1ab5cb7241a79c19e0"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_variable.html">Variable</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#af9bfb5903714cb1ab5cb7241a79c19e0">makeVarInterferenceMap</a> (<a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;ig, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;r_vars)</td></tr>
<tr class="separator:af9bfb5903714cb1ab5cb7241a79c19e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23686ebd0542ad9c82b23d5deab1718c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#a23686ebd0542ad9c82b23d5deab1718c">buildInterferenceGraph</a> (<a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;ig, <a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;instr, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;vars)</td></tr>
<tr class="separator:a23686ebd0542ad9c82b23d5deab1718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737a1f0b9915b10f5f59a49da870618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#af737a1f0b9915b10f5f59a49da870618">performSimplification</a> (<a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;ig, <a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp;sims, <a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;vars)</td></tr>
<tr class="separator:af737a1f0b9915b10f5f59a49da870618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8372818e329a28748c02110930b47f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_resource_allocation.html#a8372818e329a28748c02110930b47f77">selectRegisters</a> (<a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;ig, <a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp;ss)</td></tr>
<tr class="separator:a8372818e329a28748c02110930b47f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that will do the resource allocation There are four phases to resource allocation: Build, Simplify, Spill and Select </p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8h_source.html#l00028">28</a> of file <a class="el" href="_resource_alocation_8h_source.html">ResourceAlocation.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a23686ebd0542ad9c82b23d5deab1718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23686ebd0542ad9c82b23d5deab1718c">&#9670;&nbsp;</a></span>buildInterferenceGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp; ResourceAllocation::buildInterferenceGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First phase of <a class="el" href="class_resource_allocation.html">ResourceAllocation</a>: Function that builds an interference graph from the given instructions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ig</td><td>reference to the interference graph </td></tr>
    <tr><td class="paramname">instr</td><td>reference to the list of instruction pointers </td></tr>
    <tr><td class="paramname">vars</td><td>reference to the list of register variable pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the updated interference graph </dd></dl>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00714">714</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="a2692975fccf82a17c864e2be6a5f2f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2692975fccf82a17c864e2be6a5f2f03">&#9670;&nbsp;</a></span>createNewMemVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_variable.html">Variable</a> * ResourceAllocation::createNewMemVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>m_vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for the handleSpill function First it chooses a nemae for the var that is free, then It creates a new memory variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m_vars</td><td>reference to the list of memory variable pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new memory variable </dd></dl>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00641">641</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="a15162a951459918287ab4e61482814a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15162a951459918287ab4e61482814a8">&#9670;&nbsp;</a></span>createNewRegVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_variable.html">Variable</a> * ResourceAllocation::createNewRegVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>r_vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for the handleSpill function First it chooses a nemae for the var that is free, then It creates a new reg variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r_vars</td><td>reference to the list of register variable pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new register variable </dd></dl>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00666">666</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="ab663d36bb9dabf81d286fc8badb0a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663d36bb9dabf81d286fc8badb0a9a9">&#9670;&nbsp;</a></span>decomposeInstructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResourceAllocation::decomposeInstructions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_variable.html">Variable</a> *&#160;</td>
          <td class="paramname"><em>replaced_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decomposes the instructions that contain the variable that is being replaced example: <a class="el" href="class_instruction.html">Instruction</a> sub r1,r2,r3 can be decomposed into neg r1,r3; add r1,r1,r2; And if the register r2 can be replaced with immediate value then the resulting instructions are neg r1,r3; addi r1,r1,immediate_val That reduces the number of live variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instr</td><td>reference to a list of instruction pointers </td></tr>
    <tr><td class="paramname">replaced_var</td><td>pointer to a variable that is being spilled </td></tr>
  </table>
  </dd>
</dl>
<p>xor r1, r1, r1 add r1, r1, r2 add r1, r1, r3</p>
<p>This procedure would actually not help the program with reducing registers because if there is an register r4 that is live at the current instruction that would mean that r2,r3 and r4 are live in add r1,r2,r3 and decomposing the add instruction to the 3 instructions wouldn't change much because liveness would look like this: xor r1,r1,r1 = live r1,r4 add r1,r1,r2 = live r1,r2,r4 add r1,r1,r3 = live r1,r3,r4 So two of those instructions still have 3 variables that are live</p>
<p>xor r1, r1, r1 add r1, r1, r2 sub r1, r1, r3 <br  />
 Decomposition above would not help (see add example) with the problem of reducing the live variables</p>
<p>On the other hand this decomposition below might help if the add can be transformed into addi neg r1,r3 add r1,r1,r2 Lest assume that r4 is live at the sub instruction. That means that r2,r3 and r4 are live at the same time. If the sub instruction is replaced with neg and addi instructions then liveness looks like this neg r1,r3 = live r3,r4 addi r1,r1,(value that r2 was holding) = live r1,r4 In this case only 2 variables are live at each instruction that replaced sub instruction!</p>
<p>xor r1,r1,r1 xor r1,r1,r2 xor r1,r1,r3</p>
<p>This decomposition doesn't reduce number of live varaibles (see add and sub instructions) One solution for reducing would be to replace xor with xori in moveFromMemToImmediate function if possible</p>
<p>Remove all the instructions that were decomposed from the list of instruction pointers and also delete the instruction to free dynamically allocated memory</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00251">251</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="afa1efca3516d54ca6bd99261742b69a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1efca3516d54ca6bd99261742b69a8">&#9670;&nbsp;</a></span>handleSpill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResourceAllocation::handleSpill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>r_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>m_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_symbol_table_8h.html#aa6eccd0fcd66d7d4e48ade62e542dbc3">Labels</a> &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>spilled_vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Funcion that is activated when the spill happens. It's role is to find the register variable with the most interferences and replace it with memory variable, and also add load instructions before every use of that variable and store instructions after every declaration of that variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instr</td><td>reference to the list of instruction pointers </td></tr>
    <tr><td class="paramname">r_vars</td><td>reference to the list of register variable pointers </td></tr>
    <tr><td class="paramname">m_vars</td><td>reference to the list of memory variable pointers </td></tr>
    <tr><td class="paramname">labels</td><td>reference to the list of pairs of label and function names, and the first instructions that follow after them </td></tr>
    <tr><td class="paramname">ig</td><td>reference to the interference graph </td></tr>
    <tr><td class="paramname">spilled_vars</td><td>reference to the list of variable pointers that were already spilled to the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="struct_no_more_spills_possible.html">NoMoreSpillsPossible</a></td><td>if all the register variables are already spilled to the memory </td></tr>
  </table>
  </dd>
</dl>
<p>xor r1,r1,r1 add r1,r1,r2 add r1,r1,r3</p>
<p>sub r1,r2,r3 can be replaced with xor r1,r1,r1 sub r1,r1,r3 add r1,r1,r2</p>
<p>addi r1,r2,5 can be replaced with xor r1,r1,r1 addi r1,r1,5 add r1,r1,r2 and the ADD instruction that was created can then be transformed to immediate operand according to the procedure described below addi r1,r1,(value at the mem location)</p>
<p>xor r1,r2,r3 can be replaced with xor r1,r1,r1 xor r1,r1,r2 xor r1,r1,r3</p>
<p>la r1,m1 lw r2,0(r1) can be replaced if the value stored in m1 does not change ever (no sw that stores into it) and if the value stored in m1 can fit in 16 bits with the instruction li r2,(num value from m1)</p>
<p>first a procedure should be performed that replaces add r1,r2,r3 with three instructions, xor,add,add then it should be checked if the source register that is used is not the destination register that is being defined if it is not it should be checked if the register that is used is smaller than the size of immediate operand (addi instr) size of the immediate operand can be 16 bits (65535 unsigned or -32,768 to +32,767 signed)</p>
<p>Replace instructions where the spilled variable appears with the appropriate set of instructions if the conditions for the instruction replacement are satisfied (example: replace sub instruction only if it uses 2 different registers</p>
<p>Check if the memory variable is being used for reading only, and if it is check if it can be transformed into the immediate operand</p>
<p>Before every instruction that uses the selected regVar, we need to add 2 instructions intended for loading the instruction from memory to the selected register variable. Also for every instruction that defines the selected register variable, we need to add an instruction after it that stores the selected variable;</p>
<p>Another possible heuristic would be to find the regVar that is used the least in the program</p>
<p>It would be good if we could chose a regVar that is not inside a loop</p>
<p>real position will be calculated after all the instructions are added type of instruction is load address E → la rid, mid destination is a new registerVariable (we assume there are infinite ammount of them) source is the memory variable that replaces the regVar (it was previously created) parent label is the same lable where the encountered instruction belongs</p>
<p>real position will be calculated after all the instructions are added type of instruction is load word E → lw rid, num(rid) destination is a the register that was selected to be spilled into memory source is the register that holds the address that was loaded previously with "la" instruction parent label is the same lable where the encountered instruction belongs num is the value before the parenthesis in the "lw" instruction</p>
<p>real position will be calculated after all the instructions are added type of instruction is load address E → la rid, mid destination is a new registerVariable (we assume there are infinite ammount of them) source is the memory variable that replaces the regVar (it was previously created) parent label is the same lable where the encountered instruction belongs</p>
<p>real position will be calculated after all the instructions are added type of instruction is load word E → sw rid, num(rid) source1 is the register that was selected to be moved into memory and was defined in the current instruction destination is a the register that holds the address of the new memory variable (it is technically a "source2" because it is in the use set) parent label is the same lable where the encountered instruction belongs num is the value before the parenthesis in the "sw" instruction</p>
<p>Next add the replaced variable to the list of spilled variables. It was aded here after the other variables that were added in the process of spilling because of the easier error printing because it needs to show the variable that was chosen for the spill</p>
<p>Next step is to go trough all the instructions and choose the new position numbers for them. At the same time update the list of labels, so the labels now hold the correct position of the first instruction that belongs to them</p>
<p>Reset of some data is needed because connecting instructions, liveness analysis and register allocation has to be performed again. This reset is done at the start of the connectInstructions function in the <a class="el" href="class_symbol_table.html">SymbolTable</a> where all the data is located because this algoritham jumps back to connectInstructions after the spill happens connecting the instructions could have been performed here also, and then the algorithm would continue at liveness analysis phase</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00021">21</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="af9bfb5903714cb1ab5cb7241a79c19e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bfb5903714cb1ab5cb7241a79c19e0">&#9670;&nbsp;</a></span>makeVarInterferenceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="class_variable.html">Variable</a> *, int &gt; ResourceAllocation::makeVarInterferenceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>r_vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that creates a map for the register interferences from the interference matrix Each key is the variable pointer, and the associated value is the number of interferences for that variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ig</td><td>reference to the insterference graph </td></tr>
    <tr><td class="paramname">r_vars</td><td>reference to a list of pointers of register variables </td></tr>
  </table>
  </dd>
</dl>
<p>First the rank is calculated for all the variables, and is stored in a map</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00691">691</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="ab5a5815f7b4989d925d06fa008db1ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a5815f7b4989d925d06fa008db1ff6">&#9670;&nbsp;</a></span>moveFromMemToImmediate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResourceAllocation::moveFromMemToImmediate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a2f3fc743ecf5c73595424c6050797a36">Instructions</a> &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>m_vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the memory variables value is changed in the program and if the value is not changed (no la and sw instruction combination that writes to it) then it tries to replace lw instructions with li instruction and also tries to replace one source parameter in some instructions with immediate value (example: add instruction is changed into addi) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instr</td><td>reference to a list of instruction pointers </td></tr>
    <tr><td class="paramname">m_vars</td><td>reference to a list of memory variables </td></tr>
  </table>
  </dd>
</dl>
<p>if offset is used, this heuristic with replacing mem values with immedaite operands can potentialy not work so it is aborted. This is because it is hard to keep track what mem location is only being read from</p>
<p>For this heuristic to keep track of memory locations that are used for reading only memory address has to be loaded into register, and that register cannot be changed before it is used in the sw instruction. If sw instruction uses a register that doesn't contain an unchanged address loaded by la then this procedure is aborted.</p>
<p>Check if the mem variable value is in range to be replaced by immediate operand range is -32,768 to +32,767 for signed immediate operand (16 bits)</p>
<p>Check if there are any instructions that write to the current memory variables First check what reg variable holds the address of the m_var, and then if that reg_var is not redefined and is in sw instruction as a second source parameter, and the nubmber before the parenthesis is 0</p>
<p>la instructions that load the readonly mem loc address can't be deleted because maybe they are used for some other purpose (rare but possible) example: system call that prints the address</p>
<p>At this point the mem variables that are read only are known and they can now possibly be replaced with imediate operands</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00466">466</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="af737a1f0b9915b10f5f59a49da870618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af737a1f0b9915b10f5f59a49da870618">&#9670;&nbsp;</a></span>performSimplification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp; ResourceAllocation::performSimplification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp;&#160;</td>
          <td class="paramname"><em>sims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#ae7eea5c1baefa6e4d38750dc288c5e1f">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Second phase of <a class="el" href="class_resource_allocation.html">ResourceAllocation</a>: Function that builds the simplification stack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ig</td><td>reference to the interference graph </td></tr>
    <tr><td class="paramname">sims</td><td>reference to the simplification stack that contains <a class="el" href="class_variable.html">Variable</a> pointers </td></tr>
    <tr><td class="paramname">vars</td><td>reference to the list of register variable pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the updated interference graph </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the spill happens because the simplification stack could not be filled </td></tr>
  </table>
  </dd>
</dl>
<p>First the rank is calculated for all the variables, and is stored in a map</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00733">733</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="a8372818e329a28748c02110930b47f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8372818e329a28748c02110930b47f77">&#9670;&nbsp;</a></span>selectRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResourceAllocation::selectRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_interference_graph.html">InterferenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>ig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_i_r_8h.html#a1c1af3ee06a8a1bac85089ab3555a279">SimplificationStack</a> &amp;&#160;</td>
          <td class="paramname"><em>ss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Last phase of <a class="el" href="class_resource_allocation.html">ResourceAllocation</a>: Function that selects the registers for the variables </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ig</td><td>reference to the interference graph </td></tr>
    <tr><td class="paramname">ss</td><td>reference to the simplification stack that contains <a class="el" href="class_variable.html">Variable</a> pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the spill happens because there were not enough register left to assign </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00780">780</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<a id="a3fd01c77f504817f57450387dcc16511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd01c77f504817f57450387dcc16511">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ResourceAllocation::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_symbol_table.html">SymbolTable</a> &amp;&#160;</td>
          <td class="paramname"><em>symTab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_visitor.html">Visitor</a> class has pure virtual function visit that has to be implemented. Function visit is called by the class that this <a class="el" href="class_visitor.html">Visitor</a> visits </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symTab</td><td>class that is being visited </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_visitor.html#a73632316c39b8ceb394c950203890ab1">Visitor</a>.</p>

<p class="definition">Definition at line <a class="el" href="_resource_alocation_8cpp_source.html#l00003">3</a> of file <a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_resource_alocation_8h_source.html">ResourceAlocation.h</a></li>
<li><a class="el" href="_resource_alocation_8cpp_source.html">ResourceAlocation.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_resource_allocation.html">ResourceAllocation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
